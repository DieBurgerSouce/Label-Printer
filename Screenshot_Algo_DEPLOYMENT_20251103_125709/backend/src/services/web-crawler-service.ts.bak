/**
 * Web Crawler Service
 * Automated product detection and screenshot capture using Puppeteer
 */

import { Browser, Page } from 'puppeteer';
import puppeteerExtra from 'puppeteer-extra';
import StealthPlugin from 'puppeteer-extra-plugin-stealth';
import { v4 as uuidv4 } from 'uuid';
import * as fs from 'fs/promises';
import * as path from 'path';
import sharp from 'sharp';
import {
  CrawlJob,
  CrawlConfig,
  Screenshot,
  ProductSelectors,
  DEFAULT_CRAWL_CONFIG,
  COMMON_PRODUCT_SELECTORS,
  ExtractedElements
} from '../types/crawler-types';

// Add stealth plugin to avoid bot detection
puppeteerExtra.use(StealthPlugin());

export class WebCrawlerService {
  private browser: Browser | null = null;
  private activeJobs: Map<string, CrawlJob> = new Map();
  private screenshotsDir: string;

  constructor(screenshotsDir: string = './data/screenshots') {
    this.screenshotsDir = screenshotsDir;
  }

  /**
   * Start a new crawl job
   */
  async startCrawl(shopUrl: string, config: Partial<CrawlConfig> = {}): Promise<CrawlJob> {
    const job: CrawlJob = {
      id: uuidv4(),
      shopUrl,
      status: 'pending',
      config: { ...DEFAULT_CRAWL_CONFIG, ...config },
      results: {
        productsFound: 0,
        screenshots: [],
        errors: [],
        duration: 0,
        stats: {
          totalPages: 0,
          successfulScreenshots: 0,
          failedScreenshots: 0,
          averagePageLoadTime: 0,
          totalDataTransferred: 0
        }
      },
      createdAt: new Date()
    };

    this.activeJobs.set(job.id, job);

    // Start crawling in background
    this.executeCrawl(job).catch(error => {
      job.status = 'failed';
      job.error = error.message;
      job.completedAt = new Date();
    });

    return job;
  }

  /**
   * Execute the crawl job
   */
  private async executeCrawl(job: CrawlJob): Promise<void> {
    const startTime = Date.now();
    job.status = 'crawling';
    job.startedAt = new Date();

    try {
      // Ensure screenshots directory exists
      await this.ensureDirectory(this.screenshotsDir);

      // Launch browser
      this.browser = await puppeteerExtra.launch({
        headless: job.config.headless,
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--disable-gpu'
        ]
      });

      const page = await this.browser.newPage();

      // Set user agent
      if (job.config.userAgent) {
        await page.setUserAgent(job.config.userAgent);
      }

      // Set viewport
      await page.setViewport({ width: 1920, height: 1080 });

      // Navigate to shop URL
      console.log(`Crawling: ${job.shopUrl}`);
      await page.goto(job.shopUrl, {
        waitUntil: 'networkidle2',
        timeout: job.config.timeout
      });

      // CRITICAL: Accept cookies BEFORE crawling to avoid cookie banners on screenshots
      await this.acceptCookies(page);

      job.results.stats.totalPages++;

      // Try to detect products automatically
      const selectors = await this.detectProductSelectors(page, job.config.customSelectors);

      if (!selectors) {
        throw new Error('Could not detect product selectors. Please provide custom selectors.');
      }

      // PHASE 1: Collect ALL product links from ALL pages (no screenshots yet)
      const allProductUrls: string[] = [];

      // Collect links from first page
      const firstPageUrls = await this.collectProductLinksFromPage(page, job, selectors);
      allProductUrls.push(...firstPageUrls);
      console.log(`üìã Collected ${firstPageUrls.length} product links from page 1`);

      // Follow pagination if enabled and collect all links
      if (job.config.followPagination) {
        const paginationUrls = await this.collectAllPaginationLinks(page, job, selectors);
        allProductUrls.push(...paginationUrls);
      }

      console.log(`\nüéØ Total product links collected: ${allProductUrls.length} from ${job.results.stats.totalPages} pages`);
      console.log(`üì∏ Now capturing screenshots for all ${allProductUrls.length} products...\n`);

      // PHASE 2: Now take screenshots of ALL collected products
      await this.captureAllScreenshots(page, allProductUrls, job, selectors);

      job.status = 'completed';
      job.completedAt = new Date();
      job.results.duration = Date.now() - startTime;

    } catch (error) {
      job.status = 'failed';
      job.error = error instanceof Error ? error.message : 'Unknown error';
      job.results.errors.push({
        timestamp: new Date(),
        url: job.shopUrl,
        error: job.error,
        type: 'other',
        stack: error instanceof Error ? error.stack : undefined
      });
    } finally {
      if (this.browser) {
        await this.browser.close();
        this.browser = null;
      }
    }
  }

  /**
   * Detect product selectors automatically
   */
  private async detectProductSelectors(
    page: Page,
    customSelectors?: ProductSelectors
  ): Promise<ProductSelectors | null> {
    if (customSelectors) {
      return customSelectors;
    }

    // Try common e-commerce platforms
    for (const [platform, selectors] of Object.entries(COMMON_PRODUCT_SELECTORS)) {
      try {
        const container = await page.$(selectors.productContainer);
        if (container) {
          console.log(`Detected ${platform} platform`);
          return selectors;
        }
      } catch (error) {
        // Continue to next platform
      }
    }

    // Try generic detection
    const genericSelectors = await this.detectGenericSelectors(page);
    return genericSelectors;
  }

  /**
   * Generic product selector detection
   */
  private async detectGenericSelectors(page: Page): Promise<ProductSelectors | null> {
    try {
      // Common product container patterns
      const containerPatterns = [
        '.product', '.product-item', '.product-card',
        '[class*="product"]', '[data-product]',
        'article', '.item', '.card'
      ];

      for (const pattern of containerPatterns) {
        const containers = await page.$$(pattern);
        if (containers.length >= 3) { // At least 3 products to confirm
          // Try to detect pagination button
          const paginationPatterns = [
            'a.next', 'a[rel="next"]', '.next', '.pagination a:last-child',
            '[class*="next"]', '[class*="pagination"] a:last-child',
            'a:has-text("Next")', 'a:has-text("Weiter")', 'a:has-text("‚Ä∫")',
            '.paging a:last-child', '.pages a:last-child'
          ];

          let nextButton: string | undefined;
          for (const paginationPattern of paginationPatterns) {
            try {
              const button = await page.$(paginationPattern);
              if (button) {
                nextButton = paginationPattern;
                console.log(`‚úÖ Detected pagination button: ${nextButton}`);
                break;
              }
            } catch (e) {
              // Continue to next pattern
            }
          }

          return {
            productContainer: pattern,
            productLink: 'a',
            productImage: 'img',
            price: '[class*="price"], .price',
            articleNumber: '[class*="sku"], .sku',
            productName: '[class*="title"], [class*="name"], h2, h3',
            nextPageButton: nextButton
          };
        }
      }

      return null;
    } catch (error) {
      console.error('Generic detection failed:', error);
      return null;
    }
  }

  /**
   * NEW: Collect product links from a page (NO screenshots)
   */
  private async collectProductLinksFromPage(
    page: Page,
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<string[]> {
    try {
      // Wait for product containers
      await page.waitForSelector(selectors.productContainer, {
        timeout: 10000
      });

      if (job.config.waitForImages) {
        await page.waitForSelector(selectors.productImage, { timeout: 5000 });
      }

      // Get all product links
      const allUrls = await page.$$eval(
        `${selectors.productContainer} ${selectors.productLink}`,
        (links: any[]) => links.map((link: any) => link.href).filter(Boolean)
      );

      // Filter to ONLY product pages (not categories, legal pages, account pages)
      const productUrls = allUrls.filter(url => {
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname;

          // Skip common non-product paths
          const skipPatterns = [
            '/account', '/login', '/register', '/cart', '/checkout',
            '/AGB', '/Datenschutz', '/Impressum', '/Kontakt', '/Versand',
            '/#', // Hash links (navigation)
          ];

          if (skipPatterns.some(pattern => pathname.toLowerCase().includes(pattern.toLowerCase()))) {
            return false;
          }

          // KEY DIFFERENCE: Product pages have NO trailing slash!
          // Products: /Spargelschaeler/Der-Griffige-rot-ohne-Aufdruck (no trailing /)
          // Categories: /Ernte/Stechmesser/ (with trailing /)
          if (pathname.endsWith('/')) {
            return false; // Skip category pages
          }

          // Must have at least 2 path parts (category + product name)
          const pathParts = pathname.split('/').filter(p => p.length > 0);
          return pathParts.length >= 2;
        } catch (e) {
          return false;
        }
      });

      console.log(`‚úÖ Found ${productUrls.length} products on page (filtered from ${allUrls.length} total links)`);
      return productUrls;
    } catch (error) {
      throw new Error(`Failed to collect product links: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * NEW: Collect links from all pagination pages (NO screenshots)
   */
  private async collectAllPaginationLinks(
    page: Page,
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<string[]> {
    const allUrls: string[] = [];
    let currentPage = 1;
    const maxPages = 50;

    console.log(`\nüîÑ Starting pagination to collect links (max pages: ${maxPages}, max products: ${job.config.maxProducts})`);

    while (currentPage < maxPages) {
      try {
        // Check if max products reached
        if (job.config.maxProducts && allUrls.length >= job.config.maxProducts) {
          console.log(`‚úÖ Reached max products: ${allUrls.length}/${job.config.maxProducts}`);
          break;
        }

        // Try multiple pagination button patterns
        const paginationPatterns = [
          selectors.nextPageButton,
          'a.next', 'a[rel="next"]', '.next', '.pagination a:last-child',
          '[class*="next"]', '[class*="pagination"] a:last-child',
          'a:has-text("Next")', 'a:has-text("Weiter")', 'a:has-text("‚Ä∫")',
          '.paging a:last-child', '.pages a:last-child'
        ].filter(Boolean);

        let nextButton = null;
        let usedSelector = '';

        // Try each pattern until we find a visible button
        for (const pattern of paginationPatterns) {
          try {
            const element = await page.$(pattern as string);
            if (element) {
              const boundingBox = await element.boundingBox().catch(() => null);
              const isVisible = boundingBox !== null;
              if (isVisible) {
                nextButton = element;
                usedSelector = pattern as string;
                break;
              }
            }
          } catch (e) {
            // Continue to next pattern
          }
        }

        if (!nextButton) {
          console.log(`‚ùå No more pagination buttons found (page ${currentPage})`);
          break;
        }

        console.log(`üìÑ Clicking to page ${currentPage + 1}... (${allUrls.length} links collected so far)`);

        // Click next page and wait for AJAX to complete (no full page navigation)
        await nextButton.click();

        // Wait for AJAX pagination to complete (Puppeteer-compatible method)
        console.log(`‚è≥ Waiting for AJAX pagination...`);
        await new Promise(resolve => setTimeout(resolve, 2000)); // Short wait for AJAX request

        // Wait for product containers to reload (ensures new products are loaded)
        await page.waitForSelector(selectors.productContainer, {
          timeout: 10000
        });

        console.log(`‚úÖ Page ${currentPage + 1} loaded successfully`);

        job.results.stats.totalPages++;
        currentPage++;

        // Collect links from new page
        const pageUrls = await this.collectProductLinksFromPage(page, job, selectors);
        allUrls.push(...pageUrls);
        console.log(`üìã Collected ${pageUrls.length} links from page ${currentPage}. Total: ${allUrls.length}`);

      } catch (error) {
        console.log(`‚ùå Pagination ended at page ${currentPage}:`, error instanceof Error ? error.message : 'Unknown error');
        break;
      }
    }

    console.log(`üèÅ Pagination complete. Collected ${allUrls.length} product links from ${currentPage} pages\n`);
    return allUrls;
  }

  /**
   * NEW: Capture screenshots for all collected product URLs
   */
  private async captureAllScreenshots(
    page: Page,
    productUrls: string[],
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<void> {
    let processedCount = 0;
    const totalUrls = Math.min(productUrls.length, job.config.maxProducts || productUrls.length);

    for (const productUrl of productUrls) {
      if (job.config.maxProducts && processedCount >= job.config.maxProducts) {
        console.log(`‚úÖ Reached max products limit: ${job.config.maxProducts}`);
        break;
      }

      try {
        await this.captureProductScreenshot(page, productUrl, job, selectors);
        processedCount++;
        job.results.productsFound++;
        job.results.stats.successfulScreenshots++;

        // Log progress every 10 screenshots
        if (processedCount % 10 === 0) {
          console.log(`üì∏ Progress: ${processedCount}/${totalUrls} screenshots captured`);
        }
      } catch (error) {
        console.error(`‚ùå Failed to capture: ${productUrl}`, error instanceof Error ? error.message : 'Unknown');
        job.results.stats.failedScreenshots++;
        job.results.errors.push({
          timestamp: new Date(),
          url: productUrl,
          error: error instanceof Error ? error.message : 'Screenshot failed',
          type: 'screenshot'
        });
      }
    }

    console.log(`\n‚úÖ Screenshot capture complete: ${processedCount} successful, ${job.results.stats.failedScreenshots} failed\n`);
  }

  /**
   * LEGACY: Extract products from current page (DEPRECATED - not used anymore)
   */
  private async extractProductsFromPage(
    page: Page,
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<void> {
    try {
      // IMPORTANT: Save the current page URL so we can return to it after taking screenshots
      const listingPageUrl = page.url();

      // Wait for product containers
      await page.waitForSelector(selectors.productContainer, {
        timeout: 10000
      });

      if (job.config.waitForImages) {
        await page.waitForSelector(selectors.productImage, { timeout: 5000 });
      }

      // Get all product links
      const allUrls = await page.$$eval(
        `${selectors.productContainer} ${selectors.productLink}`,
        (links: any[]) => links.map((link: any) => link.href).filter(Boolean)
      );

      // Filter to ONLY product pages (not categories, legal pages, account pages)
      const productUrls = allUrls.filter(url => {
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname;

          // Skip common non-product paths
          const skipPatterns = [
            '/account', '/login', '/register', '/cart', '/checkout',
            '/AGB', '/Datenschutz', '/Impressum', '/Kontakt', '/Versand',
            '/#', // Hash links (navigation)
          ];

          if (skipPatterns.some(pattern => pathname.toLowerCase().includes(pattern.toLowerCase()))) {
            return false;
          }

          // KEY DIFFERENCE: Product pages have NO trailing slash!
          // Products: /Spargelschaeler/Der-Griffige-rot-ohne-Aufdruck (no trailing /)
          // Categories: /Ernte/Stechmesser/ (with trailing /)
          if (pathname.endsWith('/')) {
            return false; // Skip category pages
          }

          // Must have at least 2 path parts (category + product name)
          const pathParts = pathname.split('/').filter(p => p.length > 0);
          return pathParts.length >= 2;
        } catch (e) {
          return false;
        }
      });

      console.log(`Found ${productUrls.length} products on page (filtered from ${allUrls.length} total links)`);

      // Visit each product and take screenshot
      for (const productUrl of productUrls) {
        if (job.config.maxProducts && job.results.productsFound >= job.config.maxProducts) {
          console.log(`Reached max products limit: ${job.config.maxProducts}`);
          break;
        }

        try {
          await this.captureProductScreenshot(page, productUrl, job, selectors);
          job.results.productsFound++;
          job.results.stats.successfulScreenshots++;
        } catch (error) {
          console.error(`Failed to capture product: ${productUrl}`, error);
          job.results.stats.failedScreenshots++;
          job.results.errors.push({
            timestamp: new Date(),
            url: productUrl,
            error: error instanceof Error ? error.message : 'Screenshot failed',
            type: 'screenshot'
          });
        }
      }

      // CRITICAL: Return to the listing page so pagination can work!
      console.log(`‚úÖ Returning to listing page: ${listingPageUrl}`);
      await page.goto(listingPageUrl, {
        waitUntil: 'networkidle2',
        timeout: job.config.timeout
      });
    } catch (error) {
      throw new Error(`Failed to extract products: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  /**
   * Capture screenshot of a single product
   */
  private async captureProductScreenshot(
    page: Page,
    productUrl: string,
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<void> {
    const loadStart = Date.now();

    try {
      // Navigate to product page
      await page.goto(productUrl, {
        waitUntil: 'networkidle2',
        timeout: job.config.timeout
      });

      const loadTime = Date.now() - loadStart;

      // CRITICAL: Accept cookies on EVERY product page to remove banner from screenshots
      await this.acceptCookies(page);

      // Extract product data
      const extractedData = await this.extractProductData(page, selectors);

      // Take screenshot
      const screenshotId = uuidv4();
      const screenshotPath = path.join(this.screenshotsDir, job.id, `${screenshotId}.png`);
      const thumbnailPath = path.join(this.screenshotsDir, job.id, `${screenshotId}_thumb.png`);

      await this.ensureDirectory(path.dirname(screenshotPath));

      // üéØ TARGETED SCREENSHOTS: Capture specific elements instead of full page
      // This gives us cleaner OCR input with less noise
      const targetedScreenshots = await this.captureTargetedScreenshots(
        page,
        job.id,
        screenshotId,
        selectors
      );

      let totalFileSize = 0;
      let mainScreenshotPath = screenshotPath;
      let mainThumbnailPath = thumbnailPath;

      // Use the first successful screenshot as the main one
      if (targetedScreenshots.length > 0) {
        mainScreenshotPath = targetedScreenshots[0].path;
        mainThumbnailPath = targetedScreenshots[0].thumbnailPath;
        totalFileSize = targetedScreenshots.reduce((sum, s) => sum + s.fileSize, 0);
      } else {
        // Fallback: capture full page if no elements found
        console.warn(`‚ö†Ô∏è  No elements found for ${productUrl}, falling back to full page screenshot`);
        const screenshotBuffer = await page.screenshot({
          type: 'png',
          fullPage: true
        });
        await fs.writeFile(screenshotPath, screenshotBuffer);
        await sharp(screenshotBuffer)
          .resize(400, 400, { fit: 'inside', withoutEnlargement: true })
          .png({ quality: 80 })
          .toFile(thumbnailPath);
        const stats = await fs.stat(screenshotPath);
        totalFileSize = stats.size;
      }

      // Create screenshot record
      const screenshot: Screenshot = {
        id: screenshotId,
        url: productUrl,
        productUrl: productUrl,
        imagePath: mainScreenshotPath,
        thumbnailPath: mainThumbnailPath,
        metadata: {
          width: 1920,
          height: 0,
          timestamp: new Date(),
          pageTitle: await page.title(),
          fileSize: totalFileSize,
          format: 'png',
          targetedScreenshots: targetedScreenshots // Store all targeted screenshots
        },
        extractedElements: extractedData
      };

      job.results.screenshots.push(screenshot);
      job.results.stats.totalDataTransferred += totalFileSize;

      console.log(`‚úì Captured: ${productUrl} (${loadTime}ms)`);

    } catch (error) {
      throw error;
    }
  }

  /**
   * Extract product data from page
   */
  private async extractProductData(
    page: Page,
    selectors: ProductSelectors
  ): Promise<ExtractedElements> {
    try {
      const data: ExtractedElements = {};

      // Extract article number
      try {
        const rawArticleNumber = await page.$eval(
          selectors.articleNumber,
          (el: any) => el.textContent?.trim() || ''
        );
        // Clean article number: remove prefixes like "Artikel-Nr.:", "Art.-Nr.:", "SKU:", etc.
        data.articleNumber = this.cleanArticleNumber(rawArticleNumber);
      } catch (e) { /* Field not found */ }

      // Extract price
      try {
        data.price = await page.$eval(
          selectors.price,
          (el: any) => el.textContent?.trim() || ''
        );
      } catch (e) { /* Field not found */ }

      // Extract product name
      try {
        data.productName = await page.$eval(
          selectors.productName,
          (el: any) => el.textContent?.trim() || ''
        );
      } catch (e) { /* Field not found */ }

      // Extract product image
      try {
        data.productImage = await page.$eval(
          selectors.productImage,
          (el: any) => el.src || ''
        );
      } catch (e) { /* Field not found */ }

      // Extract description if available
      if (selectors.description) {
        try {
          data.description = await page.$eval(
            selectors.description,
            (el: any) => el.textContent?.trim() || ''
          );
        } catch (e) { /* Field not found */ }
      }

      return data;
    } catch (error) {
      console.warn('Failed to extract some product data:', error);
      return {};
    }
  }

  /**
   * Follow pagination links
   */
  private async followPagination(
    page: Page,
    job: CrawlJob,
    selectors: ProductSelectors
  ): Promise<void> {
    let currentPage = 1;
    const maxPages = 50; // Increased safety limit

    console.log(`üîÑ Starting pagination (max pages: ${maxPages}, max products: ${job.config.maxProducts})`);

    while (currentPage < maxPages) {
      try {
        // Check if max products reached
        if (job.config.maxProducts && job.results.productsFound >= job.config.maxProducts) {
          console.log(`‚úÖ Reached max products: ${job.results.productsFound}/${job.config.maxProducts}`);
          break;
        }

        // Try multiple pagination button patterns
        const paginationPatterns = [
          selectors.nextPageButton, // User-provided or detected selector
          'a.next', 'a[rel="next"]', '.next', '.pagination a:last-child',
          '[class*="next"]', '[class*="pagination"] a:last-child',
          'a:has-text("Next")', 'a:has-text("Weiter")', 'a:has-text("‚Ä∫")',
          '.paging a:last-child', '.pages a:last-child'
        ].filter(Boolean); // Remove undefined/null

        let nextButton = null;
        let usedSelector = '';

        // Try each pattern until we find a visible button
        for (const pattern of paginationPatterns) {
          try {
            const element = await page.$(pattern as string);
            if (element) {
              // Check if element is visible (Puppeteer method)
              const boundingBox = await element.boundingBox().catch(() => null);
              const isVisible = boundingBox !== null;
              if (isVisible) {
                nextButton = element;
                usedSelector = pattern as string;
                console.log(`‚úÖ Found visible pagination button: ${usedSelector}`);
                break;
              } else {
                console.log(`‚ö†Ô∏è Button found but not visible: ${pattern}`);
              }
            }
          } catch (e) {
            // Continue to next pattern
          }
        }

        if (!nextButton) {
          console.log(`‚ùå No more pagination buttons found (page ${currentPage}, products: ${job.results.productsFound})`);
          break;
        }

        console.log(`üìÑ Clicking to page ${currentPage + 1}... (${job.results.productsFound} products so far)`);

        // Click next page and wait for navigation (Puppeteer method)
        await Promise.all([
          page.waitForNavigation({ waitUntil: 'networkidle2', timeout: job.config.timeout }),
          nextButton.click()
        ]);

        job.results.stats.totalPages++;
        currentPage++;

        console.log(`üìÑ Crawling page ${currentPage}...`);

        // Extract products from new page
        await this.extractProductsFromPage(page, job, selectors);

        console.log(`‚úÖ Page ${currentPage} complete. Total products: ${job.results.productsFound}`);

      } catch (error) {
        console.log(`‚ùå Pagination ended at page ${currentPage}:`, error instanceof Error ? error.message : 'Unknown error');
        break;
      }
    }

    console.log(`üèÅ Pagination complete. Total: ${job.results.productsFound} products from ${currentPage} pages`);
  }

  /**
   * Get job status
   */
  getJob(jobId: string): CrawlJob | undefined {
    return this.activeJobs.get(jobId);
  }

  /**
   * Get all jobs
   */
  getAllJobs(): CrawlJob[] {
    return Array.from(this.activeJobs.values());
  }

  /**
   * Stop a running job
   */
  async stopJob(jobId: string): Promise<boolean> {
    const job = this.activeJobs.get(jobId);
    if (!job || job.status !== 'crawling') {
      return false;
    }

    job.status = 'failed';
    job.error = 'Stopped by user';
    job.completedAt = new Date();

    if (this.browser) {
      await this.browser.close();
      this.browser = null;
    }

    return true;
  }

  /**
   * Ensure directory exists
   */
  private async ensureDirectory(dir: string): Promise<void> {
    try {
      await fs.access(dir);
    } catch {
      await fs.mkdir(dir, { recursive: true });
    }
  }

  /**
   * Clean up old jobs
   */
  cleanupOldJobs(maxAge: number = 24 * 60 * 60 * 1000): void {
    const now = Date.now();
    for (const [jobId, job] of this.activeJobs.entries()) {
      if (job.status === 'completed' || job.status === 'failed') {
        const age = now - job.createdAt.getTime();
        if (age > maxAge) {
          this.activeJobs.delete(jobId);
        }
      }
    }
  }

  /**
   * Capture targeted screenshots of specific elements
   * Returns array of {type, path, thumbnailPath, fileSize}
   */
  private async captureTargetedScreenshots(
    page: Page,
    jobId: string,
    screenshotId: string,
    selectors: ProductSelectors
  ): Promise<Array<{type: string; path: string; thumbnailPath: string; fileSize: number}>> {
    const screenshots: Array<{type: string; path: string; thumbnailPath: string; fileSize: number}> = [];

    // Define which elements to screenshot
    const elementsToCapture = [
      { type: 'product-image', selector: 'img[itemprop="image"]', fallback: selectors.productImage },
      { type: 'article-number', selector: '[itemprop="sku"]', fallback: selectors.articleNumber },
      { type: 'title', selector: 'h1', fallback: selectors.productName },
      { type: 'price', selector: 'table.product-block-prices-grid', fallback: '.product-price' },
      { type: 'description', selector: '[itemprop="description"]', fallback: selectors.description },
    ];

    for (const elementConfig of elementsToCapture) {
      try {
        // Try primary selector first, then fallback
        const selector = elementConfig.selector;
        let element = await page.$(selector);

        if (!element && elementConfig.fallback) {
          element = await page.$(elementConfig.fallback);
        }

        if (!element) {
          console.log(`‚ö†Ô∏è  Element not found: ${elementConfig.type} (${selector})`);
          continue;
        }

        // Check if element is visible
        const boundingBox = await element.boundingBox();
        if (!boundingBox) {
          console.log(`‚ö†Ô∏è  Element not visible: ${elementConfig.type}`);
          continue;
        }

        // Add padding around element for better OCR (10px on each side)
        const padding = 10;
        const clip = {
          x: Math.max(0, boundingBox.x - padding),
          y: Math.max(0, boundingBox.y - padding),
          width: boundingBox.width + (padding * 2),
          height: boundingBox.height + (padding * 2)
        };

        // Capture element screenshot
        const screenshotPath = path.join(
          this.screenshotsDir,
          jobId,
          `${screenshotId}_${elementConfig.type}.png`
        );
        const thumbnailPath = path.join(
          this.screenshotsDir,
          jobId,
          `${screenshotId}_${elementConfig.type}_thumb.png`
        );

        const screenshotBuffer = await page.screenshot({
          type: 'png',
          clip: clip
        });

        // Save screenshot
        await fs.writeFile(screenshotPath, screenshotBuffer);

        // Create thumbnail
        await sharp(screenshotBuffer)
          .resize(400, 400, { fit: 'inside', withoutEnlargement: true })
          .png({ quality: 80 })
          .toFile(thumbnailPath);

        // Get file size
        const stats = await fs.stat(screenshotPath);

        screenshots.push({
          type: elementConfig.type,
          path: screenshotPath,
          thumbnailPath: thumbnailPath,
          fileSize: stats.size
        });

        console.log(`‚úì Captured element: ${elementConfig.type} (${(stats.size / 1024).toFixed(1)} KB)`);

      } catch (error) {
        console.error(`‚ùå Failed to capture ${elementConfig.type}:`, error instanceof Error ? error.message : 'Unknown error');
      }
    }

    if (screenshots.length === 0) {
      console.warn('‚ö†Ô∏è  No targeted screenshots captured, will fall back to full page');
    } else {
      console.log(`‚úÖ Captured ${screenshots.length} targeted screenshots`);
    }

    return screenshots;
  }

  /**
   * Clean article number by removing common prefixes and colons
   */
  private cleanArticleNumber(raw: string): string {
    if (!raw) return '';

    // Remove common prefixes (case insensitive)
    const prefixes = [
      'Artikel-Nr.',
      'Artikelnr.',
      'Artikel Nr.',
      'Art.-Nr.',
      'Art.Nr.',
      'Art Nr.',
      'SKU',
      'Produktnummer',
      'Product Number',
      'Item Number',
      'Item No.',
    ];

    let cleaned = raw.trim();

    // Remove prefixes
    for (const prefix of prefixes) {
      const regex = new RegExp(`^${prefix}\\s*:?\\s*`, 'i');
      cleaned = cleaned.replace(regex, '');
    }

    // Remove standalone colons at the beginning
    cleaned = cleaned.replace(/^:\s*/, '');

    // Remove any remaining leading/trailing whitespace
    cleaned = cleaned.trim();

    return cleaned;
  }

  /**
   * Accept all cookies to remove cookie banners from screenshots
   * CRITICAL: This must run BEFORE any product screenshots are taken!
   */
  private async acceptCookies(page: Page): Promise<void> {
    try {
      // Try multiple common cookie banner button selectors
      const cookieButtonSelectors = [
        // Text-based selectors (most reliable)
        'button:has-text("Alle Cookies akzeptieren")',
        'button:has-text("Alle akzeptieren")',
        'button:has-text("Accept all")',
        'button:has-text("Accept All Cookies")',
        'button:has-text("Akzeptieren")',
        'a:has-text("Alle Cookies akzeptieren")',
        'a:has-text("Alle akzeptieren")',

        // Common ID/class selectors
        '#onetrust-accept-btn-handler',
        '.cookie-accept-all',
        '[data-testid="cookie-accept-all"]',
        '[aria-label*="Accept"]',
        '[aria-label*="Akzeptieren"]',

        // Generic button selectors (last resort)
        'button[class*="cookie"][class*="accept"]',
        'button[class*="consent"][class*="accept"]',
        'a[class*="cookie"][class*="accept"]',

        // Firmenich-specific (from the screenshot I saw)
        'button:has-text("Alle Cookies akzeptieren")',
        '.cookie-notice button:first-child', // First button is usually "Accept all"
      ];

      let cookieAccepted = false;

      for (const selector of cookieButtonSelectors) {
        try {
          // For Puppeteer, we can't use :has-text(), so we use XPath for text-based search
          if (selector.includes(':has-text(')) {
            const text = selector.match(/:has-text\("([^"]+)"\)/)?.[1];
            if (!text) continue;

            // XPath to find button/a with specific text
            const elementType = selector.startsWith('button') ? 'button' : 'a';
            const xpath = `//${elementType}[contains(translate(text(), 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', 'abcdefghijklmnopqrstuvwxyz'), '${text.toLowerCase()}')]`;

            const elements = await page.$x(xpath);
            if (elements.length > 0) {
              await (elements[0] as any).click();
              cookieAccepted = true;
              break;
            }
          } else {
            // Regular CSS selector
            const element = await page.$(selector);
            if (element) {
              const isVisible = await element.boundingBox();
              if (isVisible) {
                await element.click();
                cookieAccepted = true;
                break;
              }
            }
          }
        } catch (e) {
          // Continue to next selector
        }
      }

      if (cookieAccepted) {
        // Wait for cookie banner to disappear
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      // Silently continue if no cookie banner found
    } catch (error) {
      // Don't throw - continue crawling even if cookie acceptance fails
    }
  }
}

// Export singleton instance
export const webCrawlerService = new WebCrawlerService();
